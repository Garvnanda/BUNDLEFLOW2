export type SupportedChain = 'avalanche' | 'aptos-testnet';
export type ChainEcosystem = 'evm' | 'aptos';
export declare const CHAIN_ECOSYSTEM_MAP: Record<SupportedChain, ChainEcosystem>;
export interface SuccessResponse {
    success: true;
}
export interface ErrorResponse {
    success: false;
    error: string;
    details?: string[];
    requestId?: string;
}
export interface ChainInfo {
    name: string;
    displayName: string;
    chainId: number;
    explorerUrl: string;
    tokens: string[];
}
export interface TokenInfo {
    symbol: string;
    address: string;
    decimals: number;
    name: string;
}
export interface ChainConfig {
    name: string;
    displayName: string;
    chainId: number;
    rpcUrl: string;
    relayerUrl: string;
    explorerUrl: string;
    tokens: string[];
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
}
export interface TransferRequest {
    from: string;
    to: string;
    token: string;
    amount: string;
    chain: SupportedChain;
}
export interface TransferQuoteResponse extends SuccessResponse {
    chainName: string;
    token: string;
    amount: string;
    relayerFee: string;
    total: string;
    feePercentage: number;
    contractAddress: string;
}
export interface TransferQuote {
    amount: string;
    relayerFee: string;
    total: string;
    feePercentage: number;
    contractAddress: string;
    aptosTransactionData?: any;
}
export interface RelayTransferResponse extends SuccessResponse {
    transferId: string;
    txHash: string;
    blockNumber: number;
    gasUsed: string;
    explorerUrl: string;
    fee: string;
    executionTime: number;
}
export interface TransferResult {
    success: boolean;
    txHash: string;
    blockNumber?: number;
    gasUsed?: string;
    transferId?: string;
    explorerUrl?: string;
    fee?: string;
    executionTime?: number;
    gasFeePaidBy?: string;
    userPaidAPT?: boolean;
    transparency?: string;
    vmStatus?: string;
    sender?: string;
    chain?: string;
    relayerFee?: string;
    message?: string;
}
export interface BatchTransferRequest {
    transfers: TransferRequest[];
    chain: SupportedChain;
}
export interface EVMTransferData {
    chainName: string;
    from: string;
    to: string;
    tokenSymbol: string;
    amount: string;
    relayerFee: string;
    nonce: string;
    deadline: number;
    signature: string;
    permitData?: {
        value: string;
        deadline: number;
        v: number;
        r: string;
        s: string;
    };
}
export type AvalancheTransferData = EVMTransferData;
export interface AptosTransferData {
    transactionBytes: number[];
    authenticatorBytes: number[];
    functionName?: string;
    fromAddress?: string;
    toAddress?: string;
    amount?: string;
    coinType?: string;
}
export interface SignatureData {
    domain: any;
    types: any;
    message: any;
    primaryType: string;
    metadata?: {
        chain?: SupportedChain;
        fromAddress?: string;
        toAddress?: string;
        amount?: string;
        token?: string;
        relayerFee?: string;
        signatureVersion?: string;
        requiresPublicKey?: boolean;
        verificationMethod?: string;
    };
}
export interface SignedTransferData {
    transferData: any;
    signature: string;
    signatureType: 'EIP712' | 'Ed25519';
    publicKey?: string;
    metadata?: {
        signatureVersion?: string;
        verificationMethod?: string;
        requiresPublicKey?: boolean;
    };
}
export interface TokenBalance {
    token: string;
    balance: string;
    decimals: number;
    symbol: string;
    name?: string;
}
export interface TransferQuoteRequest {
    chainName: string;
    token: string;
    amount: string;
}
export interface PrepareSignatureRequest {
    chainName: string;
    from: string;
    to: string;
    tokenSymbol: string;
    amount: string;
    relayerFee: string;
    nonce: string;
    deadline: number;
}
export interface RelayTransferRequest {
    chainName: string;
    from: string;
    to: string;
    tokenSymbol: string;
    amount: string;
    relayerFee: string;
    nonce: string;
    deadline: number;
    signature: string;
    permitData?: PermitData;
}
export interface BatchRelayTransferRequest {
    chainName: string;
    transfers: RelayTransferRequest[];
}
export interface EstimateGasRequest {
    chainName: string;
    transfers: TransferData[];
}
export interface TransferData {
    from: string;
    to: string;
    token: string;
    amount: string;
    relayerFee: string;
    nonce: string;
    deadline: number;
    signature: string;
    permitData?: PermitData;
}
export interface PermitData {
    value: string;
    deadline: number;
    v: number;
    r: string;
    s: string;
}
export interface PrepareSignatureResponse extends SuccessResponse {
    typedData: any;
    messageHash: string;
    message: string;
}
export interface GasEstimateResponse extends SuccessResponse {
    chainName: string;
    gasEstimate: string;
    gasPrice: string;
    estimatedCost: string;
    transferCount: number;
}
export interface HealthResponse extends SuccessResponse {
    status: string;
    timestamp: string;
    version: string;
}
export interface DomainSeparatorResponse extends SuccessResponse {
    chainName: string;
    domainSeparator: string;
}
export interface TransferStatusResponse extends SuccessResponse {
    chainName: string;
    transferHash: string;
    executed: boolean;
}
export declare class SmoothSendError extends Error {
    code: string;
    chain?: SupportedChain | undefined;
    details?: any | undefined;
    constructor(message: string, code: string, chain?: SupportedChain | undefined, details?: any | undefined);
}
export declare const APTOS_ERROR_CODES: {
    readonly MISSING_SIGNATURE: "APTOS_MISSING_SIGNATURE";
    readonly MISSING_PUBLIC_KEY: "APTOS_MISSING_PUBLIC_KEY";
    readonly INVALID_SIGNATURE_FORMAT: "APTOS_INVALID_SIGNATURE_FORMAT";
    readonly INVALID_PUBLIC_KEY_FORMAT: "APTOS_INVALID_PUBLIC_KEY_FORMAT";
    readonly ADDRESS_MISMATCH: "APTOS_ADDRESS_MISMATCH";
    readonly SIGNATURE_VERIFICATION_FAILED: "APTOS_SIGNATURE_VERIFICATION_FAILED";
    readonly MISSING_TRANSACTION_DATA: "APTOS_MISSING_TRANSACTION_DATA";
    readonly INVALID_TRANSACTION_FORMAT: "APTOS_INVALID_TRANSACTION_FORMAT";
    readonly EMPTY_ADDRESS: "APTOS_EMPTY_ADDRESS";
    readonly INVALID_ADDRESS_FORMAT: "APTOS_INVALID_ADDRESS_FORMAT";
    readonly QUOTE_ERROR: "APTOS_QUOTE_ERROR";
    readonly EXECUTE_ERROR: "APTOS_EXECUTE_ERROR";
    readonly BALANCE_ERROR: "APTOS_BALANCE_ERROR";
    readonly TOKEN_INFO_ERROR: "APTOS_TOKEN_INFO_ERROR";
    readonly STATUS_ERROR: "APTOS_STATUS_ERROR";
    readonly MOVE_CALL_ERROR: "APTOS_MOVE_CALL_ERROR";
    readonly UNSUPPORTED_TOKEN: "APTOS_UNSUPPORTED_TOKEN";
};
export type AptosErrorCode = typeof APTOS_ERROR_CODES[keyof typeof APTOS_ERROR_CODES];
export interface ApiResponse<T = any> {
    success: boolean;
    data?: T;
    error?: string;
    details?: string[];
    requestId?: string;
    errorCode?: string;
    chain?: SupportedChain;
    timestamp?: string;
}
export interface SmoothSendConfig {
    timeout?: number;
    retries?: number;
    customChainConfigs?: Partial<Record<SupportedChain, Partial<ChainConfig>>>;
    useDynamicConfig?: boolean;
    configCacheTtl?: number;
    relayerUrls?: {
        evm?: string;
        aptos?: string;
    };
}
export interface TransferEvent {
    type: 'transfer_initiated' | 'transfer_signed' | 'transfer_submitted' | 'transfer_confirmed' | 'transfer_failed';
    data: any;
    timestamp: number;
    chain: SupportedChain;
}
export type EventListener = (event: TransferEvent) => void;
export interface IChainAdapter {
    readonly chain: SupportedChain;
    readonly config: ChainConfig;
    getQuote(request: TransferRequest): Promise<TransferQuote>;
    prepareTransfer(request: TransferRequest, quote: TransferQuote): Promise<SignatureData>;
    executeTransfer(signedData: SignedTransferData): Promise<TransferResult>;
    executeBatchTransfer?(signedTransfers: SignedTransferData[]): Promise<TransferResult[]>;
    getBalance?(address: string, token?: string): Promise<TokenBalance[]>;
    getTokenInfo(token: string): Promise<TokenInfo>;
    getNonce(address: string): Promise<string>;
    getTransactionStatus(txHash: string): Promise<any>;
    validateAddress(address: string): boolean;
    validateAmount(amount: string, token: string): Promise<boolean>;
}
//# sourceMappingURL=index.d.ts.map